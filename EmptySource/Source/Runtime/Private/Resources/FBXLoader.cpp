
#include "CoreMinimal.h"
#include <fbxsdk.h>
#include "Resources/ModelParser.h"
#include "Resources/FBXLoader.h"

#include "Utility/TextFormatting.h"

namespace ESource {

	FbxManager * FBXLoader::gSdkManager = NULL;

	bool FBXLoader::InitializeSdkManager() {
		// Create the FBX SDK memory manager object.
		// The SDK Manager allocates and frees memory
		// for almost all the classes in the SDK.
		gSdkManager = FbxManager::Create();
		if (gSdkManager == NULL)
			return false;

		FbxIOSettings * IOS = FbxIOSettings::Create(gSdkManager, IOSROOT);
		IOS->SetBoolProp(IMP_FBX_MATERIAL, true);
		IOS->SetBoolProp(IMP_FBX_TEXTURE, false);
		gSdkManager->SetIOSettings(IOS);

		return true;
	}

	bool FBXLoader::LoadScene(FbxScene * pScene, const FileStream * File) {
		int FileMajor, FileMinor, FileRevision;
		int SDKMajor, SDKMinor, SDKRevision;
		// int i, lAnimStackCount;
		bool lStatus;

		// --- Get the version number of the FBX files generated by the
		// --- Version of FBX SDK that you are using.
		FbxManager::GetFileFormatVersion(SDKMajor, SDKMinor, SDKRevision);

		// --- Create an importer.
		FbxImporter* Importer = FbxImporter::Create(gSdkManager, "");

		// --- Initialize the importer by providing a filename.
		const bool ImportStatus = Importer->Initialize(Text::WideToNarrow(File->GetPath()).c_str(), -1, gSdkManager->GetIOSettings());

		// --- Get the version number of the FBX file format.
		Importer->GetFileVersion(FileMajor, FileMinor, FileRevision);

		// --- Problem with the file to be imported
		if (!ImportStatus) {
			FbxString Error = Importer->GetStatus().GetErrorString();
			LOG_CORE_ERROR(L"Import failed, error returned : {}", Text::NarrowToWide(Error.Buffer()));

			if (Importer->GetStatus().GetCode() == FbxStatus::eInvalidFileVersion) {
				LOG_CORE_INFO(L"├> FBX SDK version number: {0:d}.{1:d}.{2:d}", SDKMajor, SDKMinor, SDKRevision);
				LOG_CORE_INFO(L"└> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);
			}

			return false;
		}

		if (Importer->IsFBX()) {
			LOG_CORE_INFO(L"├> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);

			// // In FBX, a scene can have one or more "animation stack". An animation stack is a
			// // container for animation data.
			// // You can access a file's animation stack information without
			// // the overhead of loading the entire file into the scene.
			// 
			// UI_Printf("Animation Stack Information");
			// 
			// lAnimStackCount = lImporter->GetAnimStackCount();
			// 
			// UI_Printf("    Number of animation stacks: %d", lAnimStackCount);
			// UI_Printf("    Active animation stack: \"%s\"",
			// 	lImporter->GetActiveAnimStackName());
			// 
			// for (i = 0; i < lAnimStackCount; i++)
			// {
			// 	FbxTakeInfo* lTakeInfo = lImporter->GetTakeInfo(i);
			// 
			// 	UI_Printf("    Animation Stack %d", i);
			// 	UI_Printf("         Name: \"%s\"", lTakeInfo->mName.Buffer());
			// 	UI_Printf("         Description: \"%s\"",
			// 		lTakeInfo->mDescription.Buffer());
			// 
			// 	// Change the value of the import name if the animation stack should
			// 	// be imported under a different name.
			// 	UI_Printf("         Import Name: \"%s\"", lTakeInfo->mImportName.Buffer());
			// 
			// 	// Set the value of the import state to false
			// 	// if the animation stack should be not be imported.
			// 	UI_Printf("         Import State: %s", lTakeInfo->mSelect ? "true" : "false");
			// }

			// Import options determine what kind of data is to be imported.
			// The default is true, but here we set the options explictly.

			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_MATERIAL, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_TEXTURE, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_LINK, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_SHAPE, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GOBO, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_ANIMATION, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
		}

		// Import the scene.
		lStatus = Importer->Import(pScene);

		// The import file may have a password
		if (lStatus == false && Importer->GetStatus().GetCode() == FbxStatus::ePasswordError) {
			LOG_CORE_ERROR(L"File not imported, protected by password");
		}

		// Destroy the importer
		Importer->Destroy();

		return lStatus;
	}

	void FBXLoader::ExtractVertexData(FbxMesh * pMesh, MeshData & OutData) {
		int PolygonCount = pMesh->GetPolygonCount();
		FbxVector4 * ControlPoints = pMesh->GetControlPoints();
		int PolygonIndex; int PolygonVertexIndex;
		int MaterialIndex;
		bool bWarned = false;

		OutData.TextureCoordsCount = Math::Clamp(pMesh->GetElementUVCount(), 0, 2);
		OutData.hasNormals = pMesh->GetElementNormalCount() != 0;
		OutData.hasVertexColor = pMesh->GetElementVertexColorCount() != 0;

		int VertexIndex = 0;
		for (PolygonIndex = 0; PolygonIndex < PolygonCount; ++PolygonIndex) {

			int PolygonVertexSize = pMesh->GetPolygonSize(PolygonIndex);

			MeshVertex Vertex;

			for (PolygonVertexIndex = 0; PolygonVertexIndex < PolygonVertexSize; ++PolygonVertexIndex) {
				int ControlPointIndex = pMesh->GetPolygonVertex(PolygonIndex, PolygonVertexIndex);

				Vertex.Position.x = (float)ControlPoints[ControlPointIndex][0];
				Vertex.Position.y = (float)ControlPoints[ControlPointIndex][1];
				Vertex.Position.z = (float)ControlPoints[ControlPointIndex][2];

				OutData.Bounding.Add(Vertex.Position);

				ExtractTextureCoords(pMesh, Vertex, ControlPointIndex, PolygonIndex, PolygonVertexIndex);
				ExtractNormal(pMesh, Vertex, ControlPointIndex, VertexIndex);
				ExtractVertexColor(pMesh, Vertex, ControlPointIndex, VertexIndex);
				OutData.hasTangents = ExtractTangent(pMesh, Vertex, ControlPointIndex, VertexIndex);

				VertexIndex++;
				OutData.Vertices.push_back(Vertex);
			}
			MaterialIndex = ExtractMaterialIndex(pMesh, PolygonIndex);

			if (PolygonVertexSize < 4) {
				OutData.Faces.push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
				if (OutData.Subdivisions.find(MaterialIndex) != OutData.Subdivisions.end())
					OutData.Subdivisions[MaterialIndex].push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
			}
			else {
				OutData.Faces.push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
				OutData.Faces.push_back(IntVector3(VertexIndex - 4, VertexIndex - 3, VertexIndex - 1));
				if (OutData.Subdivisions.find(MaterialIndex) != OutData.Subdivisions.end()) {
					OutData.Subdivisions[MaterialIndex].push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
					OutData.Subdivisions[MaterialIndex].push_back(IntVector3(VertexIndex - 4, VertexIndex - 3, VertexIndex - 1));
				}
			}

			if (PolygonVertexSize > 4 && !bWarned) {
				bWarned = true;
				LOG_CORE_WARN(L"The model has n-gons, this may lead to unwanted geometry");
			}
		}

		OutData.ComputeTangents();
	}

	void FBXLoader::ExtractTextureCoords(
		class FbxMesh * pMesh, MeshVertex & Vertex,
		const int & ControlPointIndex, const int & PolygonIndex, const int & PolygonVertexIndex)
	{
		for (int ElementUVIndex = 0; ElementUVIndex < Math::Clamp(pMesh->GetElementUVCount(), 0, 2); ++ElementUVIndex) {
			FbxGeometryElementUV * ElementUV = pMesh->GetElementUV(ElementUVIndex);
			FbxVector2 UV;

			switch (ElementUV->GetMappingMode()) {
			case FbxGeometryElement::eByControlPoint:
				switch (ElementUV->GetReferenceMode()) {
				case FbxGeometryElement::eDirect:
					UV = ElementUV->GetDirectArray().GetAt(ControlPointIndex);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementUV->GetIndexArray().GetAt(ControlPointIndex);
					UV = ElementUV->GetDirectArray().GetAt(ID);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				} break;
				default:
					break;
				}
				break;

			case FbxGeometryElement::eByPolygonVertex: {
				int TextureUVIndex = pMesh->GetTextureUVIndex(PolygonIndex, PolygonVertexIndex);
				switch (ElementUV->GetReferenceMode()) {
				case FbxGeometryElement::eDirect:
				case FbxGeometryElement::eIndexToDirect: {
					UV = ElementUV->GetDirectArray().GetAt(TextureUVIndex);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				} break;
				default:
					break;
				}
			} break;
			default:
				break;
			}
		}
	}

	void FBXLoader::ExtractNormal(
		FbxMesh * pMesh, MeshVertex & Vertex,
		const int & ControlPointIndex, const int & VertexIndex)
	{
		FbxVector4 Normal;
		int ElementNormalCount = pMesh->GetElementNormalCount();

		if (ElementNormalCount > 0) {
			FbxGeometryElementNormal* ElementNormal = pMesh->GetElementNormal(0);
			if (ElementNormal->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementNormal->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Normal = ElementNormal->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementNormal->GetIndexArray().GetAt(ControlPointIndex);
					Normal = ElementNormal->GetDirectArray().GetAt(ID);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				default:
					break;
				}
			}
			else if (ElementNormal->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementNormal->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Normal = ElementNormal->GetDirectArray().GetAt(VertexIndex);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementNormal->GetIndexArray().GetAt(VertexIndex);
					Normal = ElementNormal->GetDirectArray().GetAt(ID);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				default:
					break;
				}
			}
		}
	}

	void FBXLoader::ExtractVertexColor(
		FbxMesh * pMesh, MeshVertex & Vertex,
		const int & ControlPointIndex, const int & VertexIndex)
	{
		FbxColor Color;
		int ElementColorCount = pMesh->GetElementVertexColorCount();

		if (ElementColorCount > 0) {
			FbxGeometryElementVertexColor* ElementColor = pMesh->GetElementVertexColor(0);
			if (ElementColor->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementColor->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Color = ElementColor->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementColor->GetIndexArray().GetAt(ControlPointIndex);
					Color = ElementColor->GetDirectArray().GetAt(ID);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				default:
					break;
				}
			}
			else if (ElementColor->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementColor->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Color = ElementColor->GetDirectArray().GetAt(VertexIndex);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementColor->GetIndexArray().GetAt(VertexIndex);
					Color = ElementColor->GetDirectArray().GetAt(ID);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				default:
					break;
				}
			}
		} else {
			Vertex.Color = { 1.F };
		}
	}

	int FBXLoader::ExtractMaterialIndex(FbxMesh * pMesh, const int & PolygonIndex) {
		int MaterialIndex = pMesh->GetElementMaterialCount();

		if (MaterialIndex > 0) {
			FbxGeometryElementMaterial* ElementMaterial = pMesh->GetElementMaterial();
			if (ElementMaterial->GetMappingMode() == FbxGeometryElement::eAllSame) {
				return ElementMaterial->GetIndexArray().GetAt(0);
			}
			else {
				return ElementMaterial->GetIndexArray().GetAt(PolygonIndex);
			}
		}

		return -1;
	}

	bool FBXLoader::ExtractTangent(FbxMesh * pMesh, MeshVertex & Vertex, const int & ControlPointIndex, const int & VertexIndex) {
		FbxVector4 Tangent;
		int ElementTangentCount = pMesh->GetElementTangentCount();

		if (ElementTangentCount > 0) {
			FbxGeometryElementTangent* ElementTangent = pMesh->GetElementTangent(0);
			if (ElementTangent->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementTangent->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Tangent = ElementTangent->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementTangent->GetIndexArray().GetAt(ControlPointIndex);
					Tangent = ElementTangent->GetDirectArray().GetAt(ID);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				default:
					break;
				}
			}
			else if (ElementTangent->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementTangent->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Tangent = ElementTangent->GetDirectArray().GetAt(VertexIndex);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementTangent->GetIndexArray().GetAt(VertexIndex);
					Tangent = ElementTangent->GetDirectArray().GetAt(ID);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				default:
					break;
				}
			}
		}
		return false;
	}

	bool FBXLoader::LoadModel(ModelParser::ModelDataInfo & Info, const ModelParser::ParsingOptions & Options) {
		if (gSdkManager == NULL)
			return false;

		Timestamp Timer;
		Timer.Begin();

		FbxScene* Scene = FbxScene::Create(gSdkManager, Text::WideToNarrow(Options.File->GetShortPath()).c_str());

		bool bStatus = LoadScene(Scene, Options.File);
		if (bStatus == false) return false;

		FbxAxisSystem::OpenGL.ConvertScene(Scene);
		FbxSystemUnit::m.ConvertScene(Scene);

		// FbxGeometryConverter GeomConverter(gSdkManager);
		// GeomConverter.Triangulate(Scene, true);
		const int NodeCount = Scene->GetSrcObjectCount<FbxNode>();
		size_t TotalAllocatedSize = 0;

		Timer.Stop();
		LOG_CORE_INFO(L"├> Readed and parsed in {:0.3f}ms", Timer.GetDeltaTime<Time::Mili>());

		Timer.Begin();
		for (int NodeIndex = 0; NodeIndex < NodeCount; NodeIndex++) {
			FbxNode * Node = Scene->GetSrcObject<FbxNode>(NodeIndex);
			FbxMesh * lMesh = Node->GetMesh();
			if (lMesh) {
				Info.Meshes.push_back(MeshData());
				Info.Meshes.back().Name = lMesh->GetName();
				const int MaterialCount = Node->GetMaterialCount();
				for (int MaterialIndex = 0; MaterialIndex < MaterialCount; ++MaterialIndex) {
					Info.Meshes.back().Materials.insert({ MaterialIndex, Node->GetMaterial(MaterialIndex)->GetName() });
					Info.Meshes.back().Subdivisions.insert({ MaterialIndex, MeshFaces() });
				}
				ExtractVertexData(lMesh, Info.Meshes.back());

#ifdef ES_DEBUG
				LOG_CORE_DEBUG(L"├> Parsed {0}	vertices in {1}	at [{2:d}]'{3}'",
					Text::FormatUnit(ResourceData.Meshes.back().Vertices.size(), 2),
					Text::FormatData(sizeof(IntVector3) * ResourceData.Meshes.back().Faces.size() + sizeof(MeshVertex) * ResourceData.Meshes.back().Vertices.size(), 2),
					ResourceData.Meshes.size(),
					Text::NarrowToWide(Node->GetName())
				);
#endif
				TotalAllocatedSize += sizeof(IntVector3) * Info.Meshes.back().Faces.size() + sizeof(MeshVertex) * Info.Meshes.back().Vertices.size();
			}
		}

		Timer.Stop();
		LOG_CORE_INFO(L"└> Allocated {0} in {1:.2f}ms", Text::FormatData(TotalAllocatedSize, 2), Timer.GetDeltaTime<Time::Mili>());

		return bStatus;
	}

}