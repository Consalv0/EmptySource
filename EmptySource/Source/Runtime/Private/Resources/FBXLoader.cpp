
#include "CoreMinimal.h"
#include <fbxsdk.h>
#include "Resources/ModelParser.h"
#include "Resources/FBXLoader.h"
#include "Resources/ModelResource.h"

#include "Utility/TextFormatting.h"

namespace ESource {

	FbxManager * FBXLoader::gSdkManager = NULL;

	bool FBXLoader::InitializeSdkManager() {
		// Create the FBX SDK memory manager object.
		// The SDK Manager allocates and frees memory
		// for almost all the classes in the SDK.
		gSdkManager = FbxManager::Create();
		if (gSdkManager == NULL)
			return false;

		FbxIOSettings * IOS = FbxIOSettings::Create(gSdkManager, IOSROOT);
		IOS->SetBoolProp(IMP_FBX_MATERIAL, true);
		IOS->SetBoolProp(IMP_FBX_TEXTURE, false);
		gSdkManager->SetIOSettings(IOS);

		return true;
	}

	bool FBXLoader::LoadScene(FbxScene * pScene, const FileStream * File) {
		int FileMajor, FileMinor, FileRevision;
		int SDKMajor, SDKMinor, SDKRevision;
		// int i, lAnimStackCount;
		bool lStatus;

		// --- Get the version number of the FBX files generated by the
		// --- Version of FBX SDK that you are using.
		FbxManager::GetFileFormatVersion(SDKMajor, SDKMinor, SDKRevision);

		// --- Create an importer.
		FbxImporter* Importer = FbxImporter::Create(gSdkManager, "");

		// --- Initialize the importer by providing a filename.
		const bool ImportStatus = Importer->Initialize(Text::WideToNarrow(File->GetPath()).c_str(), -1, gSdkManager->GetIOSettings());

		// --- Get the version number of the FBX file format.
		Importer->GetFileVersion(FileMajor, FileMinor, FileRevision);

		// --- Problem with the file to be imported
		if (!ImportStatus) {
			FbxString Error = Importer->GetStatus().GetErrorString();
			LOG_CORE_ERROR(L"Import failed, error returned : {}", Text::NarrowToWide(Error.Buffer()));

			if (Importer->GetStatus().GetCode() == FbxStatus::eInvalidFileVersion) {
				LOG_CORE_INFO(L"├> FBX SDK version number: {0:d}.{1:d}.{2:d}", SDKMajor, SDKMinor, SDKRevision);
				LOG_CORE_INFO(L"└> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);
			}

			return false;
		}

		if (Importer->IsFBX()) {
			LOG_CORE_INFO(L"├> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);

			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_MATERIAL, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_TEXTURE, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_LINK, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GOBO, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_ANIMATION, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
		}

		// Import the scene.
		lStatus = Importer->Import(pScene);

		// The import file may have a password
		if (lStatus == false && Importer->GetStatus().GetCode() == FbxStatus::ePasswordError) {
			LOG_CORE_ERROR(L"File not imported, protected by password");
		}

		// Destroy the importer
		Importer->Destroy();

		return lStatus;
	}

	bool FBXLoader::LoadAnimationStack(FbxScene * pScene, const FileStream * File) {
		int FileMajor, FileMinor, FileRevision;
		int SDKMajor, SDKMinor, SDKRevision;
		// int i, lAnimStackCount;
		bool lStatus;
		return false; // ---------------------------------------------------------------------------------------------------------------------------------

		// --- Get the version number of the FBX files generated by the
		// --- Version of FBX SDK that you are using.
		FbxManager::GetFileFormatVersion(SDKMajor, SDKMinor, SDKRevision);

		// --- Create an importer.
		FbxImporter* Importer = FbxImporter::Create(gSdkManager, "");

		// --- Initialize the importer by providing a filename.
		const bool ImportStatus = Importer->Initialize(Text::WideToNarrow(File->GetPath()).c_str(), -1, gSdkManager->GetIOSettings());

		// --- Get the version number of the FBX file format.
		Importer->GetFileVersion(FileMajor, FileMinor, FileRevision);

		// --- Problem with the file to be imported
		if (!ImportStatus) {
			FbxString Error = Importer->GetStatus().GetErrorString();
			LOG_CORE_ERROR(L"Import failed, error returned : {}", Text::NarrowToWide(Error.Buffer()));

			if (Importer->GetStatus().GetCode() == FbxStatus::eInvalidFileVersion) {
				LOG_CORE_INFO(L"├> FBX SDK version number: {0:d}.{1:d}.{2:d}", SDKMajor, SDKMinor, SDKRevision);
				LOG_CORE_INFO(L"└> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);
			}

			return false;
		}


		if (Importer->IsFBX()) {
			LOG_CORE_INFO(L"├> FBX version number: {0:d}.{1:d}.{2:d}", FileMajor, FileMinor, FileRevision);

			// In FBX, a scene can have one or more "animation stack". An animation stack is a
			// container for animation data.
			// You can access a file's animation stack information without
			// the overhead of loading the entire file into the scene.
			
			int AnimStackCount = Importer->GetAnimStackCount();
			
			LOG_CORE_DEBUG("    Number of animation stacks: {}", AnimStackCount);
			LOG_CORE_DEBUG("    Active animation stack: \"{}\"",
				Importer->GetActiveAnimStackName());
			
			for (int i = 0; i < AnimStackCount; i++)
			{
				FbxTakeInfo* lTakeInfo = Importer->GetTakeInfo(i);
			
				LOG_CORE_INFO("    Animation Stack {}", i);
				LOG_CORE_INFO("         Name: \"{}\"", lTakeInfo->mName.Buffer());
				LOG_CORE_INFO("         Description: \"{}\"",
					lTakeInfo->mDescription.Buffer());
			
				// Change the value of the import name if the animation stack should
				// be imported under a different name.
				LOG_CORE_INFO("         Import Name: \"{}\"", lTakeInfo->mImportName.Buffer());
			
				// Set the value of the import state to false
				// if the animation stack should be not be imported.
				LOG_CORE_INFO("         Import State: {}", lTakeInfo->mSelect ? "true" : "false");
			}

			// Import options determine what kind of data is to be imported.
			// The default is true, but here we set the options explictly.

			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_MATERIAL, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_TEXTURE, false);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_LINK, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_SHAPE, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GOBO, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_ANIMATION, true);
			(*(gSdkManager->GetIOSettings())).SetBoolProp(IMP_FBX_GLOBAL_SETTINGS, true);
		}

		// Import the scene.
		lStatus = Importer->Import(pScene);

		// The import file may have a password
		if (lStatus == false && Importer->GetStatus().GetCode() == FbxStatus::ePasswordError) {
			LOG_CORE_ERROR(L"File not imported, protected by password");
		}

		// Destroy the importer
		Importer->Destroy();

		return lStatus;
	}

	void FBXLoader::ExtractVertexData(FbxMesh * pMesh, MeshData & OutData) {
		int PolygonCount = pMesh->GetPolygonCount();
		FbxVector4 * ControlPoints = pMesh->GetControlPoints();
		int PolygonIndex; int PolygonVertexIndex;
		int MaterialIndex;
		bool bWarned = false;

		OutData.UVChannels = Math::Clamp(pMesh->GetElementUVCount(), 0, 2);
		OutData.hasNormals = pMesh->GetElementNormalCount() != 0;
		OutData.hasVertexColor = pMesh->GetElementVertexColorCount() != 0;

		TArray<int> VertexIndexCountByMaterial = TArray<int>(OutData.MaterialsMap.size());
		TArray<int> FaceIndexCountByMaterial = TArray<int>(OutData.MaterialsMap.size());

		FbxDouble3 Translation = pMesh->GetNode()->GeometricTranslation.Get();
		FbxDouble3 Rotation = pMesh->GetNode()->GeometricRotation.Get();
		FbxDouble3 Scaling = pMesh->GetNode()->GeometricScaling.Get();

		Matrix4x4 GeometricTransform =
			Matrix4x4::Scaling({ (float)Scaling[0], (float)Scaling[1], (float)Scaling[2] }) *
			Matrix4x4::Rotation({ (float)Rotation[0], (float)Rotation[1], (float)Rotation[2] }) *
			Matrix4x4::Translation({ (float)Translation[0], (float)Translation[1], (float)Translation[2] });

		int VertexIndex = 0;
		for (PolygonIndex = 0; PolygonIndex < PolygonCount; ++PolygonIndex) {

			int PolygonVertexSize = pMesh->GetPolygonSize(PolygonIndex);

			StaticVertex Vertex;

			for (PolygonVertexIndex = 0; PolygonVertexIndex < PolygonVertexSize; ++PolygonVertexIndex) {
				int ControlPointIndex = pMesh->GetPolygonVertex(PolygonIndex, PolygonVertexIndex);

				Vertex.Position.x = (float)ControlPoints[ControlPointIndex][0];
				Vertex.Position.y = (float)ControlPoints[ControlPointIndex][1];
				Vertex.Position.z = (float)ControlPoints[ControlPointIndex][2];
				Vertex.Position = GeometricTransform * Vector4(Vertex.Position, 1.F);

				OutData.Bounding.Add(Vertex.Position);

				ExtractTextureCoords(pMesh, Vertex, ControlPointIndex, PolygonIndex, PolygonVertexIndex);
				ExtractNormal(pMesh, Vertex, ControlPointIndex, VertexIndex);
				ExtractVertexColor(pMesh, Vertex, ControlPointIndex, VertexIndex);
				OutData.hasTangents = ExtractTangent(pMesh, Vertex, ControlPointIndex, VertexIndex);

				VertexIndex++;
				OutData.StaticVertices.push_back(Vertex);
			}
			MaterialIndex = ExtractMaterialIndex(pMesh, PolygonIndex);
			if (OutData.SubdivisionsMap.find(MaterialIndex + 1) != OutData.SubdivisionsMap.end()) {
				VertexIndexCountByMaterial[MaterialIndex + 1] += PolygonVertexSize;
				FaceIndexCountByMaterial[MaterialIndex + 1] += PolygonVertexSize < 4 ? 3 : 6;
			}

			if (PolygonVertexSize < 4) {
				OutData.Faces.push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
				if (OutData.SubdivisionsMap.find(MaterialIndex) != OutData.SubdivisionsMap.end()) {
					OutData.SubdivisionsMap[MaterialIndex].IndexCount += 3;
				}
			}
			else {
				OutData.Faces.push_back(IntVector3(VertexIndex - 3, VertexIndex - 2, VertexIndex - 1));
				OutData.Faces.push_back(IntVector3(VertexIndex - 4, VertexIndex - 3, VertexIndex - 1));
				if (OutData.SubdivisionsMap.find(MaterialIndex) != OutData.SubdivisionsMap.end()) {
					OutData.SubdivisionsMap[MaterialIndex].IndexCount += 6;
				}
			}

			if (PolygonVertexSize > 4 && !bWarned) {
				bWarned = true;
				LOG_CORE_WARN(L"The model has n-gons, this may lead to incorrect geometry");
			}
		}

		OutData.ComputeTangents();
		
		for (auto & SubdivisionIt : OutData.SubdivisionsMap) {
			SubdivisionIt.second.MaterialIndex = SubdivisionIt.first;
			SubdivisionIt.second.BaseVertex = VertexIndexCountByMaterial[SubdivisionIt.first];
			SubdivisionIt.second.BaseIndex = FaceIndexCountByMaterial[SubdivisionIt.first];
		}
	}

	void FBXLoader::ExtractTextureCoords(
		class FbxMesh * pMesh, StaticVertex & Vertex,
		const int & ControlPointIndex, const int & PolygonIndex, const int & PolygonVertexIndex)
	{
		for (int ElementUVIndex = 0; ElementUVIndex < Math::Clamp(pMesh->GetElementUVCount(), 0, 2); ++ElementUVIndex) {
			FbxGeometryElementUV * ElementUV = pMesh->GetElementUV(ElementUVIndex);
			FbxVector2 UV;

			switch (ElementUV->GetMappingMode()) {
			case FbxGeometryElement::eByControlPoint:
				switch (ElementUV->GetReferenceMode()) {
				case FbxGeometryElement::eDirect:
					UV = ElementUV->GetDirectArray().GetAt(ControlPointIndex);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementUV->GetIndexArray().GetAt(ControlPointIndex);
					UV = ElementUV->GetDirectArray().GetAt(ID);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				} break;
				default:
					break;
				}
				break;

			case FbxGeometryElement::eByPolygonVertex: {
				int TextureUVIndex = pMesh->GetTextureUVIndex(PolygonIndex, PolygonVertexIndex);
				switch (ElementUV->GetReferenceMode()) {
				case FbxGeometryElement::eDirect:
				case FbxGeometryElement::eIndexToDirect: {
					UV = ElementUV->GetDirectArray().GetAt(TextureUVIndex);

					switch (ElementUVIndex) {
					case 0:
						Vertex.UV0.u = (float)UV[0];
						Vertex.UV0.v = (float)UV[1];
						if (pMesh->GetElementUVCount() == 1) {
							Vertex.UV1.u = (float)UV[0];
							Vertex.UV1.v = (float)UV[1];
						}
						break;
					case 1:
						Vertex.UV1.u = (float)UV[0];
						Vertex.UV1.v = (float)UV[1];
						break;
					}
				} break;
				default:
					break;
				}
			} break;
			default:
				break;
			}
		}
	}

	void FBXLoader::ExtractNormal(
		FbxMesh * pMesh, StaticVertex & Vertex,
		const int & ControlPointIndex, const int & VertexIndex)
	{
		FbxVector4 Normal;
		int ElementNormalCount = pMesh->GetElementNormalCount();

		if (ElementNormalCount > 0) {
			FbxGeometryElementNormal* ElementNormal = pMesh->GetElementNormal(0);
			if (ElementNormal->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementNormal->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Normal = ElementNormal->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementNormal->GetIndexArray().GetAt(ControlPointIndex);
					Normal = ElementNormal->GetDirectArray().GetAt(ID);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				default:
					break;
				}
			}
			else if (ElementNormal->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementNormal->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Normal = ElementNormal->GetDirectArray().GetAt(VertexIndex);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementNormal->GetIndexArray().GetAt(VertexIndex);
					Normal = ElementNormal->GetDirectArray().GetAt(ID);

					Vertex.Normal.x = (float)Normal[0];
					Vertex.Normal.y = (float)Normal[1];
					Vertex.Normal.z = (float)Normal[2];
				} break;
				default:
					break;
				}
			}
		}
	}

	void FBXLoader::ExtractVertexColor(
		FbxMesh * pMesh, StaticVertex & Vertex,
		const int & ControlPointIndex, const int & VertexIndex)
	{
		FbxColor Color;
		int ElementColorCount = pMesh->GetElementVertexColorCount();

		if (ElementColorCount > 0) {
			FbxGeometryElementVertexColor* ElementColor = pMesh->GetElementVertexColor(0);
			if (ElementColor->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementColor->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Color = ElementColor->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementColor->GetIndexArray().GetAt(ControlPointIndex);
					Color = ElementColor->GetDirectArray().GetAt(ID);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				default:
					break;
				}
			}
			else if (ElementColor->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementColor->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Color = ElementColor->GetDirectArray().GetAt(VertexIndex);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementColor->GetIndexArray().GetAt(VertexIndex);
					Color = ElementColor->GetDirectArray().GetAt(ID);

					Vertex.Color.r = (float)Color.mRed;
					Vertex.Color.g = (float)Color.mGreen;
					Vertex.Color.b = (float)Color.mBlue;
					Vertex.Color.a = (float)Color.mAlpha;
				} break;
				default:
					break;
				}
			}
		} else {
			Vertex.Color = { 1.F };
		}
	}

	int FBXLoader::ExtractMaterialIndex(FbxMesh * pMesh, const int & PolygonIndex) {
		int MaterialIndex = pMesh->GetElementMaterialCount();

		if (MaterialIndex > 0) {
			FbxGeometryElementMaterial* ElementMaterial = pMesh->GetElementMaterial();
			if (ElementMaterial->GetMappingMode() == FbxGeometryElement::eAllSame) {
				return ElementMaterial->GetIndexArray().GetAt(0);
			}
			else {
				return ElementMaterial->GetIndexArray().GetAt(PolygonIndex);
			}
		}

		return -1;
	}

	bool FBXLoader::ExtractTangent(FbxMesh * pMesh, StaticVertex & Vertex, const int & ControlPointIndex, const int & VertexIndex) {
		FbxVector4 Tangent;
		int ElementTangentCount = pMesh->GetElementTangentCount();

		if (ElementTangentCount > 0) {
			FbxGeometryElementTangent* ElementTangent = pMesh->GetElementTangent(0);
			if (ElementTangent->GetMappingMode() == FbxGeometryElement::eByControlPoint) {
				switch (ElementTangent->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Tangent = ElementTangent->GetDirectArray().GetAt(ControlPointIndex);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementTangent->GetIndexArray().GetAt(ControlPointIndex);
					Tangent = ElementTangent->GetDirectArray().GetAt(ID);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				default:
					break;
				}
			}
			else if (ElementTangent->GetMappingMode() == FbxGeometryElement::eByPolygonVertex) {
				switch (ElementTangent->GetReferenceMode()) {
				case FbxGeometryElement::eDirect: {
					Tangent = ElementTangent->GetDirectArray().GetAt(VertexIndex);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				case FbxGeometryElement::eIndexToDirect: {
					int ID = ElementTangent->GetIndexArray().GetAt(VertexIndex);
					Tangent = ElementTangent->GetDirectArray().GetAt(ID);

					Vertex.Tangent.x = (float)Tangent[0];
					Vertex.Tangent.y = (float)Tangent[1];
					Vertex.Tangent.z = (float)Tangent[2];
					return true;
				} break;
				default:
					break;
				}
			}
		}
		return false;
	}

	void FBXLoader::ExtractNodeTransform(FbxNode * pNode, class FbxScene * pScene, Transform & Transformation) {
		FbxEuler::EOrder NodeRotationOrder;
		pNode->GetRotationOrder(FbxNode::EPivotSet::eSourcePivot, NodeRotationOrder);
		FbxAMatrix LocalTransform = pNode->EvaluateLocalTransform();
		FbxAMatrix PreRotation;
		PreRotation.SetR(pNode->GetPreRotation(FbxNode::EPivotSet::eSourcePivot), NodeRotationOrder);
		FbxAMatrix PostRotation;
		PostRotation.SetR(pNode->GetPostRotation(FbxNode::EPivotSet::eSourcePivot), NodeRotationOrder);

		FbxAMatrix ResultTransform = PostRotation * LocalTransform * PreRotation;

		FbxDouble3 RTranslation = ResultTransform.GetT();
		FbxDouble3 RRotation = ResultTransform.GetR();
		FbxDouble3 RScaling = ResultTransform.GetS();

		FbxAMatrix GMatrix = pNode->EvaluateGlobalTransform();
		FbxAMatrix GIMatrix = GMatrix.Inverse();
		FbxVector4 RotationA = pNode->LclRotation.Get();
		FbxVector4 RotationB = GMatrix.GetR();
		FbxVector4 RotationC = pNode->GetPreRotation(FbxNode::eSourcePivot);
		FbxVector4 RotationD = pNode->GetPostRotation(FbxNode::eSourcePivot);
		FbxDouble3 Rotation = (
			FbxAMatrix(FbxVector4(), RotationA, FbxVector4({ 1.0, 1.0, 1.0, 1.0 })) * FbxAMatrix(FbxVector4(), RotationC, FbxVector4({ 1.0, 1.0, 1.0, 1.0 }))
		).GetR();
		FbxVector4 ScaleA = (pNode->GetParent() == NULL || pNode->GetParent()->GetParent() == NULL) ? GMatrix.GetS() : FbxVector4(1.0, 1.0, 1.0);
		FbxDouble3 Scale = (FbxVector4)pNode->LclScaling.Get() / ScaleA;
		FbxDouble3 TranslationA = GMatrix.GetT();
		FbxDouble3 TranslationB = pNode->LclTranslation.Get();
		FbxDouble3 TranslationC = pNode->GetGeometricTranslation(FbxNode::eSourcePivot);

		Transformation.Position[0] = (float)RTranslation[0];
		Transformation.Position[1] = (float)RTranslation[1];
		Transformation.Position[2] = (float)RTranslation[2];
		Transformation.Rotation = Quaternion::EulerAngles({ 
			(float)(RRotation[0]),
			(float)(RRotation[1]), 
			(float)(RRotation[2])
		});
		Transformation.Scale[0] = (float)RScaling[0];
		Transformation.Scale[1] = (float)RScaling[1];
		Transformation.Scale[2] = (float)RScaling[2];
	}

	void SetUpNode(FbxNode * pNode) {
		FbxVector4 lZero(0, 0, 0);
		
		// Activate pivot converting
		pNode->SetPivotState(FbxNode::eSourcePivot, FbxNode::ePivotActive);
		pNode->SetPivotState(FbxNode::eDestinationPivot, FbxNode::ePivotActive);
		
		// We want to set all these to 0 and bake them into the transforms.
		pNode->SetPostRotation(FbxNode::eDestinationPivot, lZero);
		pNode->SetPreRotation(FbxNode::eDestinationPivot, lZero);
		pNode->SetRotationOffset(FbxNode::eDestinationPivot, lZero);
		pNode->SetScalingOffset(FbxNode::eDestinationPivot, lZero);
		pNode->SetRotationPivot(FbxNode::eDestinationPivot, lZero);
		pNode->SetScalingPivot(FbxNode::eDestinationPivot, lZero);
		
		// This is to import in a system that supports rotation order.
		// If rotation order is not supported, do this instead:
		// pNode->SetRotationOrder(FbxNode::eDestinationPivot, FbxNode::eEulerXYZ);
		FbxEuler::EOrder lRotationOrder;
		pNode->GetRotationOrder(FbxNode::eSourcePivot, lRotationOrder);
		pNode->SetRotationOrder(FbxNode::eDestinationPivot, lRotationOrder);
		
		// Similarly, this is the case where geometric transforms are supported by the system.
		// If geometric transforms are not supported, set them to zero instead of
		// the source’s geometric transforms.
		// Geometric transform = local transform, not inherited by children.
		pNode->SetGeometricTranslation(FbxNode::eDestinationPivot, pNode->GetGeometricTranslation(FbxNode::eSourcePivot));
		pNode->SetGeometricRotation(FbxNode::eDestinationPivot, pNode->GetGeometricRotation(FbxNode::eSourcePivot));
		pNode->SetGeometricScaling(FbxNode::eDestinationPivot, pNode->GetGeometricScaling(FbxNode::eSourcePivot));
	}

	bool FBXLoader::LoadModel(ModelParser::ModelDataInfo & Info, const ModelParser::ParsingOptions & Options) {
		if (gSdkManager == NULL)
			return false;

		Timestamp Timer;
		Timer.Begin();

		FbxScene* Scene = FbxScene::Create(gSdkManager, Text::WideToNarrow(Options.File->GetShortPath()).c_str());

		bool bStatus = LoadScene(Scene, Options.File);
		if (bStatus == false) return false;

		FbxAxisSystem::OpenGL.ConvertScene(Scene);
		FbxSystemUnit SceneSystemUnit = Scene->GetGlobalSettings().GetSystemUnit();
		if (SceneSystemUnit != FbxSystemUnit::m) {
			FbxSystemUnit::m.ConvertScene(Scene);
		}

		// FbxGeometryConverter GeomConverter(gSdkManager);
		// GeomConverter.Triangulate(Scene, true);
		const int NodeCount = Scene->GetSrcObjectCount<FbxNode>();
		size_t TotalAllocatedSize = 0;
		TDictionary<FbxUInt64, size_t> FBXNodeMap;
		TArray<ModelNode *> NodeMap;
		for (int NodeIndex = 0; NodeIndex < NodeCount; NodeIndex++) {
			FbxNode * Node = Scene->GetSrcObject<FbxNode>(NodeIndex);
			SetUpNode(Node);
			FBXNodeMap.emplace(Node->GetUniqueID(), NodeMap.size());
			if (NodeIndex == 0) {
				NodeMap.emplace_back(&Info.ParentNode);
				Info.ParentNode.Name = Node->GetName();
			}
			else {
				NodeMap.emplace_back(new ModelNode(Node->GetName()));
			}
		}

		Scene->GetRootNode()->ConvertPivotAnimationRecursive(NULL, FbxNode::eDestinationPivot, 30.0);

		Timer.Stop();
		LOG_CORE_INFO(L"├> Readed and parsed in {:0.3f}ms", Timer.GetDeltaTime<Time::Mili>());

		Timer.Begin();
		for (int NodeIndex = 0; NodeIndex < NodeCount; NodeIndex++) {
			FbxNode * Node = Scene->GetSrcObject<FbxNode>(NodeIndex);
			FbxMesh * lMesh = Node->GetMesh();
			ModelNode * CurrentSceneNode = NodeMap[FBXNodeMap[Node->GetUniqueID()]];
			ExtractNodeTransform(Node, Scene, CurrentSceneNode->LocalTransform);
			if (Node->GetParent() != NULL)
				CurrentSceneNode->Parent = NodeMap[FBXNodeMap[Node->GetParent()->GetUniqueID()]];
			int ChildCount = Node->GetChildCount();
			for (int ChildIndex = 0; ChildIndex < ChildCount; ++ChildIndex) {
				CurrentSceneNode->Children.push_back(NodeMap[FBXNodeMap[Node->GetChild(ChildIndex)->GetUniqueID()]]);
			}
			if (lMesh) {
				CurrentSceneNode->bHasMesh = true;
				CurrentSceneNode->MeshKey = Info.Meshes.size();
				Info.Meshes.push_back(MeshData());
				MeshData & CurrentMeshData = Info.Meshes.back();
				CurrentMeshData.Name = lMesh->GetName();
				if (CurrentMeshData.Name.size() == 0) CurrentMeshData.Name = CurrentSceneNode->Name;
				const int MaterialCount = Node->GetMaterialCount();
				for (int MaterialIndex = 0; MaterialIndex < MaterialCount; ++MaterialIndex) {
					CurrentMeshData.MaterialsMap.emplace(MaterialIndex, Node->GetMaterial(MaterialIndex)->GetName());
					CurrentMeshData.SubdivisionsMap.emplace(MaterialIndex, Subdivision());
				}
				ExtractVertexData(lMesh, CurrentMeshData);
			
#ifdef ES_DEBUG
				LOG_CORE_DEBUG(L"├> Parsed {0}	vertices in {1}	at [{2:d}]'{3}'",
					Text::FormatUnit(CurrentMeshData.StaticVertices.size(), 2),
					Text::FormatData(sizeof(IntVector3) * CurrentMeshData.Faces.size() + sizeof(StaticVertex) * CurrentMeshData.StaticVertices.size(), 2),
					Info.Meshes.size(),
					Text::NarrowToWide(CurrentSceneNode->Name)
				);
#endif		
				TotalAllocatedSize += sizeof(IntVector3) * CurrentMeshData.Faces.size() + sizeof(StaticVertex) * CurrentMeshData.StaticVertices.size();
			}
		}

		Timer.Stop();
		LOG_CORE_INFO(L"└> Allocated {0} in {1:.2f}ms", Text::FormatData(TotalAllocatedSize, 2), Timer.GetDeltaTime<Time::Mili>());

		return bStatus;
	}

}